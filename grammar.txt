http://craftinginterpreters.com/representing-code.html#context-free-grammars

stmt            -> FN|ACT IDENTIFIER LPAR (IDENTIFIER,)* RPAR LBRACE (expr|return|assignment|if_statement|loop SEMICOLON)+ RBRACE SEMICOLON #Function/Non-returning function definition
                -> DEC ACT? IDENTIFIER LPAR (IDENTIFIER,)* RPAR SEMICOLON #Function declaration/prototype
                -> assignment SEMICOLON #Only let assignment

if_statement    -> IF expr LBRACE (expr|return|assignment|if_statement|loop SEMICOLON)* RBRACE
                -> IF expr LBRACE (expr|return|assignment|if_statement|loop SEMICOLON)* RBRACE ELSE LBRACE (expr|return|assignment|if_statement)*

loop            -> LOOP LBRACE (expr)* RBRACE

return          -> RET expr
                -> BREAK #This isn't really a return but it works the same in terms of grammar

assignment      -> IDENTIFIER (":=") expr
                -> LET IDENTIFIER (":=") expr

expr            -> comparison

comparison      -> term ((">"|"<"|"=") term)*

term            -> factor (("+"|"-") factor)*

factor          -> unary ("*" unary)*

unary           -> ("+"|"-") unary 
                -> primary

primary         -> (NUMBER|IDENTIFIER) 
                -> LPAR expr RPAR
                -> IDENTIFIER LPAR (expr,)* RPAR #Function call